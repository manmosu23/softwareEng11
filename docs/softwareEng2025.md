---
layout: page
title: "software Eng. lecture note"
permalink: /docs/softwareEng2025
---



# 第１３回github課題

## 第１回講義まとめ
　第１回では、ソフトウェア工学の講義の概要についてだった。ここで、これからの授業のスケジュールや何をしていくかを確認した。

## 第２回講義まとめ
　第２回では、ソフトウェア工学概論１ということで、ソフトウェア工学とは何か、今なぜソフトウェア工学が必要なのかについてだった。
　ソフトウェア工学とは、「品質」、「コスト」、「納期」の最適なバランスを実現するための手法・方法論のことだ。現在の社会はソフトウェアなしでは回らないものになっているため、そのソフトウェアを効率よく開発し、メンテナンスできる人材が今後さらに必要になっている。また、利用者のニーズが変化し続けているので、そのニーズに対応するためにもソフトウェア工学は必要だ。

## 第３回講義まとめ
　第3回ではソフトウェアライフサイクルということで、ソフトウェアの誕生から開発・運用、廃止までの流れについてだった。
　まず、ソフトウェアの誕生はニーズの発生から始まり、そのニーズに合うシステムを作る計画をする。そして、その計画を具現化するうえで、ソフトウェアを作る前に要件定義をする。要件定義とはどういうものを作るのか定義することで、実現する機能・実現しない機能を明確にすることが重要になる。
　ソフトウェア開発では、まず要件定義書をもとに設計書を書き、それに従って制作する。制作方法は主に自社開発と外部委託の２つがある。自社開発はそのままの意味だが、一部機能をパッケージとして外部から購入する場合もある。外部委託では納品物にソースコードを含めるかどうかで対応が変わり、含める場合はメンテナンスを自社で行えるが、含めない場合はそれが不可能となる。複数人でのソフトウェア開発の場合はドキュメンテーションを使うので、非同期コミュニケーションが重要になってくる。ソフトウェアの保守ではテストとデバッグが行われる。バグのないソフトウェアは存在しないので、あらかじめテストしバグを早期発見・対処するのが理想だ。

## 第４回講義まとめ
　第４回ではプロジェクト・ソフトウェア分析・開発プロセスについてだった。
　プロジェクトを計画するうえで、フォアキャスティングとバックキャスティングという考え方がある。フォアキャスティングは現状から順に目標に進んでいく考え方で、目標に到達できない可能性がある。バックキャスティングは定めた目標から逆算して計画することで、目標を明確に設定する必要がある。プロジェクト業務はバックキャスティングで行われる。
　ソフトウェアを分析するにあたって、物量、実行性能、開発工数、品質の４つの観点から分析する。まず、物量の観点ではステップ数（ソースコード行数など）・オブジェクト容量の大きさから評価する。実行性能では画面の視認性・操作性・入力補助・互換性・ガイダンスなどで評価する。開発工数はファンクションポイント法を使って評価する。この方法を使うことで、必要な機能が見えてきた段階でシステム規模を概算することが可能になる。品質はバグ発生率を基準に評価する。
　開発プロセスには様々な種類があるが、今回は４つ紹介する。１つ目は、ウォーターフォール型だ。この方法は要件定義から開発、テストまでを一気に行う手法で、進捗管理が容易になり、成果物が明確になるが、その分後工程にしわ寄せが集中するリスクがある。
　２つ目はスパイラルモデルで、プログラム開発を小さなフェーズに分割し、そのフェーズごとにプロトタイプによるデモンストレーションを行い、フィードバックする。この方法ではプロトタイプ作成時に想定外の作業量が発生するリスクがある。
　３つ目は反復型開発プロセスで、ソフトウェアを機能分割し、これを反復という単位で管理する。メリットとしては部分的に完成させていくことによる顧客の要求の取り入れやすさや部分的な納品が可能なことがあるが、デメリットとして分割による業務の増加や全体像が見えづらいことが挙げられる。
　４つ目はアジャイルプロセスだ。アジャイルプロセスでは、計画から実装、テストまでの工程を小さなサイクルで繰り返す。この方法を使うと、変化に柔軟に対応することができる。この方法のフレームワークの一つにスクラムがあるが、これは少人数でチームを結成して「スプリント」と呼ばれる短期間の開発サイクルを繰り返す方法だ。

## 第５回講義まとめ
　第５回ではWBSについての話だった。WBSとは、プロジェクト目標を達成し、必要な要素成果物を生成するためにプロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したものだ。これを作るメリットとしては、やることとやらないことや全体管理、作業計画などが明確になったり、プロジェクト実施時はWBSに則り実行するのみになったりすることだ。
　作り方としては、まずスコープを明確にし、大きな作業をグルーピングする。そうしてグルーピングした作業の相互関連を考え、各グループの作業を洗い出す。

## 第６回講義まとめ
　第６回では第５回で出たWBS演習の続きが行われた。

## 第７回講義まとめ
　第7回ではコーディングについてだった。コードは書くよりも読まれることのほうが多いので、読みやすいように書く必要がある。そのためにはルールが必要で、今回は例としてPythonのPEP8を学んだ。
　主なルールとしては１行の長さ、レイアウト、スペース、改行、import、コメント、命名規則についてのものがある。まず、１行の長さは79文字以内にする必要があり、行を継続する場合は折り返された要素を縦に加える。レイアウトについては、１レベルインデントするごとにスペースを４つ使う。スペースの置く場所は演算子の前後で、無駄なスペースは入れてはいけない。改行をするときは、文を重ねず、演算子の位置を揃えるように意識するとよい。importの順番は最初に標準ライブラリ、次にサードパーティに関するもの、最後にローカルなアプリケーション・ライブラリに特有のものにする。コメントはコードと矛盾しないように気を付け、少しでも外国の方に読まれる可能性があるなら英語で分かりやすいように書く。命名規則についても、小文字か大文字か、アンダースコアを使うかなど様々なルールがある。
　このルール通りにコーディングできているか調べるチェックツールがある。代表的なものとしてはflake8とpylintがある。この講義では、課題でflake8を使用した。

## 第８回講義まとめ
　第８回ではバージョン管理やgitについてだった。バージョン管理とは、ファイルを誰がいつ、どのように変更したかを管理することだ。これらの情報を管理することで、多数のメンバーと共同でコード開発ができる。これには集中管理型と分散管理型の２種類がある。
　集中管理型ではレポジトリはリモートのみで、同時編集をするとコンフリクトが発生しやすく、同期に時間がかかるという欠点がある。分散管理型にはローカルレポジトリも存在し、リモートリポジトリへのアクセス頻度が低く、障害に強いのが特徴だ。
　gitは分散管理型のバージョン管理システムで、変更履歴が残ったり、変更した箇所に戻したり、他人と共同編集ができたりする。ここからは、gitを使う上で必要な知識を説明する。
　まず、コミットについてだ。コミットとは、ファイル作成・変更・削除の記録をすることで、コミットする時は何を変更したのかメッセージを残す必要がある。対象ファイルの数は指定されておらず、コミットするタイミングはユーザーが自由に決定できる。
　レポジトリとは、gitが管理するプロジェクトのフォルダのことで、ローカルレポジトリが個々のプロジェクト実行環境、リモートレポジトリが共有の管理場所だ。レポジトリではワークツリーと呼ばれるもので、ファイルを３つの種類に分けて管理する。その３つの種類とはuntracked、unmodified、modifiedだ。それぞれ、gitで管理されていないファイルの状態、gitで管理されているが変更されていないファイルの状態、gitで管理されていて変更されたファイルの状態を指す。
　gitの主な流れとしては、まず、gitで管理するファイルを登録（ステージング）し、コミットにより変更を登録する。このコミットは原則変更・削除できない。コミットされたファイルはunmodifiedの状態になる。ここから、ローカルレポジトリでコミットされた変更をリモートレポジトリへ反映し、リモートレポジトリにある内容をローカルレポジトリに反映する。この一連の作業をする際、ブランチと呼ばれる作業を枝分かれさせる機能を使うのもよい。

## 第９回講義まとめ
　第９回ではデトロイトトーマツベンチャーサポート株式会社の前田さんの話を聞いた。この話は主に起業についての話だった。自分は起業するつもりはないが、起業家の発想力は参考にしなければなと思った。

## 第１０回講義まとめ
　第１０回ではLearning git branchingを使ってgithubの使い方について学んだ。

## 第１１回講義まとめ
　第１１回ではgithub演習で学んだことを活かして実際にgithubを使って課題に取り組み、提出した。

## 第１２回講義まとめ
　第１２回はCI/CDについてだった。CIとは、コード変更を共有リポジトリに頻繁に統合するプロセスのことで、自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能にする。これの自動化により、開発のスムーズな進行を促進する。
　CDとは、コード変更をテスト環境や本番環境に自動的にデプロイするプロセスで、自動デプロイメントを埋め込むことで手動操作によるデプロイの必要性を排除する。これによって、ユーザーフィードバックを迅速に反映できる。
　CI/CDパイプラインの基本的なステップとしては、まずコード変更をトリガーにワークフローを起動し、ソースコードをコンパイル、自動テストを実施する。そうしてできたテスト済みのコードを本番環境にデプロイし、そのアプリケーションの動作確認、継続的に監視する。
　GitHub Actionsを使用してCI/CDを行う場合、ワークフローの定義はYAMLファイルで行い、.github/workflows/ディレクトリに配置する。トリガーはプッシュ、プルリクエスト、スケジュールなど様々なものでワークフローを起動することができる。ジョブは並列実行が可能で、ステップではシェルコマンドの実行やアクションの使用が可能だ。アクションとしては再利用可能なワークフローの構成要素、コミュニティが作成したアクションも利用可能。ランナーはGitHub提供のホステッドランナーまたはセルフホステッドランナーが使用可能だ。
　この講義では、課題としてgithubでflake8を適用することを行った。

## 第１３回講義まとめ
　第１３回では、CI/CDの実践ということで、Githubにあるリモートレポジトリの内容をwebpageとして公開した。

## 第１４回まとめ
　第１４回では、テスト手法やデバッグ、今までの講義のまとめについてだった。プログラムのバグの早期発見のために、プログラムはテストを行わなければならない。
　テスト方法としてはブラックボックステストとホワイトボックステストがある。ブラックボックステストは内部処理を把握せずに対処するやり方で、返り値や入力を工夫することでどのようなエラーが出るかテストする。ホワイトボックステストは中身を見ながら行うテストなのでより詳しくテストできるが、コストがかかってしまう。テストのコストを抑えるためには、テストのデザインを工夫する必要がある。
　テストのコストを抑えるもう一つの方法としてテストの自動化がある。これは最近ではツールを活用することで実現できる。前の回で学んだCIも活用できる。このテストは、機械学習、深層学習では特に必須となる。
　次に、デバッグとはバグを取り除く作業のことで、リアクティブアプローチ、プロアクティブアプローチの２つがある。リアクティブアプローチはバグが発見されてから対処するやり方で、プロアクティブアプローチはバグがないように事前に対処する方法だ。
　PDCAとは、Planで目標設定、計画立案をし、Doで実行、Checkで実行内容の検証、Actionで検証結果から改善点を検討する。OODAとは、Observeで情報収集をし、Orientでやるべきことの方向性を定め、Decideで具体的な行動の準備、Actで実行する。
　最後に、卒業研究を例にとって今まで学んだ内容をまとめた。